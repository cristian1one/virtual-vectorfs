// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: files.sql

package database

import (
	"context"
	"database/sql"
)

const batchCreateFiles = `-- name: BatchCreateFiles :exec
INSERT INTO files (
        id,
        workspace_id,
        file_path,
        size,
        mod_time,
        is_dir,
        checksum,
        embedding,
        metadata,
        created_at,
        updated_at
    )
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type BatchCreateFilesParams struct {
	ID          string       `json:"id"`
	WorkspaceID string       `json:"workspace_id"`
	FilePath    string       `json:"file_path"`
	Size        int64        `json:"size"`
	ModTime     int64        `json:"mod_time"`
	IsDir       sql.NullBool `json:"is_dir"`
	Checksum    string       `json:"checksum"`
	Embedding   interface{}  `json:"embedding"`
	Metadata    string       `json:"metadata"`
	CreatedAt   int64        `json:"created_at"`
	UpdatedAt   int64        `json:"updated_at"`
}

// Batch insert multiple files
func (q *Queries) BatchCreateFiles(ctx context.Context, arg BatchCreateFilesParams) error {
	_, err := q.exec(ctx, q.batchCreateFilesStmt, batchCreateFiles,
		arg.ID,
		arg.WorkspaceID,
		arg.FilePath,
		arg.Size,
		arg.ModTime,
		arg.IsDir,
		arg.Checksum,
		arg.Embedding,
		arg.Metadata,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	return err
}

const batchDeleteFiles = `-- name: BatchDeleteFiles :exec
DELETE FROM files
WHERE id = ?
`

// Batch delete multiple files
func (q *Queries) BatchDeleteFiles(ctx context.Context, id string) error {
	_, err := q.exec(ctx, q.batchDeleteFilesStmt, batchDeleteFiles, id)
	return err
}

const batchUpdateFiles = `-- name: BatchUpdateFiles :exec
UPDATE files
SET size = ?,
    mod_time = ?,
    checksum = ?,
    embedding = ?,
    metadata = ?,
    updated_at = ?
WHERE id = ?
`

type BatchUpdateFilesParams struct {
	Size      int64       `json:"size"`
	ModTime   int64       `json:"mod_time"`
	Checksum  string      `json:"checksum"`
	Embedding interface{} `json:"embedding"`
	Metadata  string      `json:"metadata"`
	UpdatedAt int64       `json:"updated_at"`
	ID        string      `json:"id"`
}

// Batch update multiple files
func (q *Queries) BatchUpdateFiles(ctx context.Context, arg BatchUpdateFilesParams) error {
	_, err := q.exec(ctx, q.batchUpdateFilesStmt, batchUpdateFiles,
		arg.Size,
		arg.ModTime,
		arg.Checksum,
		arg.Embedding,
		arg.Metadata,
		arg.UpdatedAt,
		arg.ID,
	)
	return err
}

const bulkUpdateFileEmbeddings = `-- name: BulkUpdateFileEmbeddings :exec
UPDATE files
SET embedding = ?,
    updated_at = ?
WHERE id = ?
`

type BulkUpdateFileEmbeddingsParams struct {
	Embedding interface{} `json:"embedding"`
	UpdatedAt int64       `json:"updated_at"`
	ID        string      `json:"id"`
}

// Bulk update embeddings for multiple files
func (q *Queries) BulkUpdateFileEmbeddings(ctx context.Context, arg BulkUpdateFileEmbeddingsParams) error {
	_, err := q.exec(ctx, q.bulkUpdateFileEmbeddingsStmt, bulkUpdateFileEmbeddings, arg.Embedding, arg.UpdatedAt, arg.ID)
	return err
}

const createFile = `-- name: CreateFile :one
INSERT INTO files (
        id,
        workspace_id,
        file_path,
        size,
        mod_time,
        is_dir,
        checksum,
        embedding,
        metadata,
        created_at,
        updated_at
    )
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?) ON CONFLICT(workspace_id, file_path) DO
UPDATE
SET size = excluded.size,
    mod_time = excluded.mod_time,
    checksum = excluded.checksum,
    embedding = excluded.embedding,
    metadata = excluded.metadata,
    updated_at = excluded.updated_at
RETURNING id,
    workspace_id,
    file_path,
    size,
    mod_time,
    is_dir,
    checksum,
    embedding,
    metadata,
    created_at,
    updated_at
`

type CreateFileParams struct {
	ID          string       `json:"id"`
	WorkspaceID string       `json:"workspace_id"`
	FilePath    string       `json:"file_path"`
	Size        int64        `json:"size"`
	ModTime     int64        `json:"mod_time"`
	IsDir       sql.NullBool `json:"is_dir"`
	Checksum    string       `json:"checksum"`
	Embedding   interface{}  `json:"embedding"`
	Metadata    string       `json:"metadata"`
	CreatedAt   int64        `json:"created_at"`
	UpdatedAt   int64        `json:"updated_at"`
}

// Create a new file with upsert semantics
func (q *Queries) CreateFile(ctx context.Context, arg CreateFileParams) (File, error) {
	row := q.queryRow(ctx, q.createFileStmt, createFile,
		arg.ID,
		arg.WorkspaceID,
		arg.FilePath,
		arg.Size,
		arg.ModTime,
		arg.IsDir,
		arg.Checksum,
		arg.Embedding,
		arg.Metadata,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i File
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.FilePath,
		&i.Size,
		&i.ModTime,
		&i.IsDir,
		&i.Checksum,
		&i.Embedding,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteFile = `-- name: DeleteFile :exec
DELETE FROM files
WHERE id = ?
`

// Delete file by ID
func (q *Queries) DeleteFile(ctx context.Context, id string) error {
	_, err := q.exec(ctx, q.deleteFileStmt, deleteFile, id)
	return err
}

const getFile = `-- name: GetFile :one
SELECT id,
    workspace_id,
    file_path,
    size,
    mod_time,
    is_dir,
    checksum,
    embedding,
    metadata,
    created_at,
    updated_at
FROM files
WHERE id = ?
`

// Get file by ID
func (q *Queries) GetFile(ctx context.Context, id string) (File, error) {
	row := q.queryRow(ctx, q.getFileStmt, getFile, id)
	var i File
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.FilePath,
		&i.Size,
		&i.ModTime,
		&i.IsDir,
		&i.Checksum,
		&i.Embedding,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getFileByPath = `-- name: GetFileByPath :one
SELECT id,
    workspace_id,
    file_path,
    size,
    mod_time,
    is_dir,
    checksum,
    embedding,
    metadata,
    created_at,
    updated_at
FROM files
WHERE workspace_id = ?
    AND file_path = ?
`

type GetFileByPathParams struct {
	WorkspaceID string `json:"workspace_id"`
	FilePath    string `json:"file_path"`
}

// Get file by workspace and path
func (q *Queries) GetFileByPath(ctx context.Context, arg GetFileByPathParams) (File, error) {
	row := q.queryRow(ctx, q.getFileByPathStmt, getFileByPath, arg.WorkspaceID, arg.FilePath)
	var i File
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.FilePath,
		&i.Size,
		&i.ModTime,
		&i.IsDir,
		&i.Checksum,
		&i.Embedding,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getFileStatsByWorkspace = `-- name: GetFileStatsByWorkspace :one
SELECT COUNT(*) as total_files,
    SUM(size) as total_size,
    AVG(size) as avg_file_size,
    COUNT(
        CASE
            WHEN is_dir THEN 1
        END
    ) as directory_count,
    COUNT(
        CASE
            WHEN NOT is_dir THEN 1
        END
    ) as file_count,
    COUNT(
        CASE
            WHEN embedding IS NOT NULL THEN 1
        END
    ) as files_with_embeddings,
    MAX(mod_time) as latest_modification,
    MIN(created_at) as oldest_file
FROM files
WHERE workspace_id = ?
`

type GetFileStatsByWorkspaceRow struct {
	TotalFiles          int64           `json:"total_files"`
	TotalSize           sql.NullFloat64 `json:"total_size"`
	AvgFileSize         sql.NullFloat64 `json:"avg_file_size"`
	DirectoryCount      int64           `json:"directory_count"`
	FileCount           int64           `json:"file_count"`
	FilesWithEmbeddings int64           `json:"files_with_embeddings"`
	LatestModification  interface{}     `json:"latest_modification"`
	OldestFile          interface{}     `json:"oldest_file"`
}

// Get file statistics for a workspace
func (q *Queries) GetFileStatsByWorkspace(ctx context.Context, workspaceID string) (GetFileStatsByWorkspaceRow, error) {
	row := q.queryRow(ctx, q.getFileStatsByWorkspaceStmt, getFileStatsByWorkspace, workspaceID)
	var i GetFileStatsByWorkspaceRow
	err := row.Scan(
		&i.TotalFiles,
		&i.TotalSize,
		&i.AvgFileSize,
		&i.DirectoryCount,
		&i.FileCount,
		&i.FilesWithEmbeddings,
		&i.LatestModification,
		&i.OldestFile,
	)
	return i, err
}

const getFilesBySizeRange = `-- name: GetFilesBySizeRange :many
SELECT id,
    workspace_id,
    file_path,
    size,
    mod_time,
    is_dir,
    checksum,
    embedding,
    metadata,
    created_at,
    updated_at
FROM files
WHERE workspace_id = ?
    AND size BETWEEN ? AND ?
ORDER BY size DESC
LIMIT ? OFFSET ?
`

type GetFilesBySizeRangeParams struct {
	WorkspaceID string `json:"workspace_id"`
	Limit       int64  `json:"limit"`
	Offset      int64  `json:"offset"`
}

// Get files within a size range
func (q *Queries) GetFilesBySizeRange(ctx context.Context, arg GetFilesBySizeRangeParams) ([]File, error) {
	rows, err := q.query(ctx, q.getFilesBySizeRangeStmt, getFilesBySizeRange, arg.WorkspaceID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []File{}
	for rows.Next() {
		var i File
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.FilePath,
			&i.Size,
			&i.ModTime,
			&i.IsDir,
			&i.Checksum,
			&i.Embedding,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFilesWithEmbeddings = `-- name: GetFilesWithEmbeddings :many
SELECT id,
    workspace_id,
    file_path,
    size,
    mod_time,
    is_dir,
    checksum,
    embedding,
    metadata,
    created_at,
    updated_at
FROM files
WHERE workspace_id = ?
    AND embedding IS NOT NULL
ORDER BY updated_at DESC
LIMIT ? OFFSET ?
`

type GetFilesWithEmbeddingsParams struct {
	WorkspaceID string `json:"workspace_id"`
	Limit       int64  `json:"limit"`
	Offset      int64  `json:"offset"`
}

// Get files that have embeddings (for semantic search)
func (q *Queries) GetFilesWithEmbeddings(ctx context.Context, arg GetFilesWithEmbeddingsParams) ([]File, error) {
	rows, err := q.query(ctx, q.getFilesWithEmbeddingsStmt, getFilesWithEmbeddings, arg.WorkspaceID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []File{}
	for rows.Next() {
		var i File
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.FilePath,
			&i.Size,
			&i.ModTime,
			&i.IsDir,
			&i.Checksum,
			&i.Embedding,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFilesWithoutEmbeddings = `-- name: GetFilesWithoutEmbeddings :many
SELECT id,
    workspace_id,
    file_path,
    size,
    mod_time,
    is_dir,
    checksum,
    metadata,
    created_at,
    updated_at
FROM files
WHERE workspace_id = ?
    AND embedding IS NULL
    AND NOT is_dir
ORDER BY size DESC
LIMIT ? OFFSET ?
`

type GetFilesWithoutEmbeddingsParams struct {
	WorkspaceID string `json:"workspace_id"`
	Limit       int64  `json:"limit"`
	Offset      int64  `json:"offset"`
}

type GetFilesWithoutEmbeddingsRow struct {
	ID          string       `json:"id"`
	WorkspaceID string       `json:"workspace_id"`
	FilePath    string       `json:"file_path"`
	Size        int64        `json:"size"`
	ModTime     int64        `json:"mod_time"`
	IsDir       sql.NullBool `json:"is_dir"`
	Checksum    string       `json:"checksum"`
	Metadata    string       `json:"metadata"`
	CreatedAt   int64        `json:"created_at"`
	UpdatedAt   int64        `json:"updated_at"`
}

// Get files that need embedding generation
func (q *Queries) GetFilesWithoutEmbeddings(ctx context.Context, arg GetFilesWithoutEmbeddingsParams) ([]GetFilesWithoutEmbeddingsRow, error) {
	rows, err := q.query(ctx, q.getFilesWithoutEmbeddingsStmt, getFilesWithoutEmbeddings, arg.WorkspaceID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetFilesWithoutEmbeddingsRow{}
	for rows.Next() {
		var i GetFilesWithoutEmbeddingsRow
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.FilePath,
			&i.Size,
			&i.ModTime,
			&i.IsDir,
			&i.Checksum,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecentlyModifiedFiles = `-- name: GetRecentlyModifiedFiles :many
SELECT id,
    workspace_id,
    file_path,
    size,
    mod_time,
    is_dir,
    checksum,
    embedding,
    metadata,
    created_at,
    updated_at
FROM files
WHERE workspace_id = ?
    AND mod_time >= ?
ORDER BY mod_time DESC
LIMIT ? OFFSET ?
`

type GetRecentlyModifiedFilesParams struct {
	WorkspaceID string `json:"workspace_id"`
	ModTime     int64  `json:"mod_time"`
	Limit       int64  `json:"limit"`
	Offset      int64  `json:"offset"`
}

// Get files modified within a time range
func (q *Queries) GetRecentlyModifiedFiles(ctx context.Context, arg GetRecentlyModifiedFilesParams) ([]File, error) {
	rows, err := q.query(ctx, q.getRecentlyModifiedFilesStmt, getRecentlyModifiedFiles,
		arg.WorkspaceID,
		arg.ModTime,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []File{}
	for rows.Next() {
		var i File
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.FilePath,
			&i.Size,
			&i.ModTime,
			&i.IsDir,
			&i.Checksum,
			&i.Embedding,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFilesByDirectory = `-- name: ListFilesByDirectory :many
SELECT id,
    workspace_id,
    file_path,
    size,
    mod_time,
    is_dir,
    checksum,
    embedding,
    metadata,
    created_at,
    updated_at
FROM files
WHERE workspace_id = ?
    AND file_path LIKE ? || '/%'
ORDER BY file_path
`

type ListFilesByDirectoryParams struct {
	WorkspaceID string         `json:"workspace_id"`
	Column2     sql.NullString `json:"column_2"`
}

// List files in a specific directory path
func (q *Queries) ListFilesByDirectory(ctx context.Context, arg ListFilesByDirectoryParams) ([]File, error) {
	rows, err := q.query(ctx, q.listFilesByDirectoryStmt, listFilesByDirectory, arg.WorkspaceID, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []File{}
	for rows.Next() {
		var i File
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.FilePath,
			&i.Size,
			&i.ModTime,
			&i.IsDir,
			&i.Checksum,
			&i.Embedding,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFilesByWorkspace = `-- name: ListFilesByWorkspace :many
SELECT id,
    workspace_id,
    file_path,
    size,
    mod_time,
    is_dir,
    checksum,
    embedding,
    metadata,
    created_at,
    updated_at
FROM files
WHERE workspace_id = ?
ORDER BY file_path
LIMIT ? OFFSET ?
`

type ListFilesByWorkspaceParams struct {
	WorkspaceID string `json:"workspace_id"`
	Limit       int64  `json:"limit"`
	Offset      int64  `json:"offset"`
}

// List all files in a workspace with pagination
func (q *Queries) ListFilesByWorkspace(ctx context.Context, arg ListFilesByWorkspaceParams) ([]File, error) {
	rows, err := q.query(ctx, q.listFilesByWorkspaceStmt, listFilesByWorkspace, arg.WorkspaceID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []File{}
	for rows.Next() {
		var i File
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.FilePath,
			&i.Size,
			&i.ModTime,
			&i.IsDir,
			&i.Checksum,
			&i.Embedding,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchFiles = `-- name: SearchFiles :many
SELECT id,
    workspace_id,
    file_path,
    size,
    mod_time,
    is_dir,
    checksum,
    embedding,
    metadata,
    created_at,
    updated_at
FROM files
WHERE workspace_id = ?
    AND (
        file_path LIKE '%' || ? || '%'
        OR metadata LIKE '%' || ? || '%'
    )
ORDER BY updated_at DESC
LIMIT ? OFFSET ?
`

type SearchFilesParams struct {
	WorkspaceID string         `json:"workspace_id"`
	Column2     sql.NullString `json:"column_2"`
	Column3     sql.NullString `json:"column_3"`
	Limit       int64          `json:"limit"`
	Offset      int64          `json:"offset"`
}

// Search files by path or metadata content
func (q *Queries) SearchFiles(ctx context.Context, arg SearchFilesParams) ([]File, error) {
	rows, err := q.query(ctx, q.searchFilesStmt, searchFiles,
		arg.WorkspaceID,
		arg.Column2,
		arg.Column3,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []File{}
	for rows.Next() {
		var i File
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.FilePath,
			&i.Size,
			&i.ModTime,
			&i.IsDir,
			&i.Checksum,
			&i.Embedding,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateFile = `-- name: UpdateFile :one
UPDATE files
SET size = ?,
    mod_time = ?,
    checksum = ?,
    embedding = ?,
    metadata = ?,
    updated_at = ?
WHERE id = ?
RETURNING id,
    workspace_id,
    file_path,
    size,
    mod_time,
    is_dir,
    checksum,
    embedding,
    metadata,
    created_at,
    updated_at
`

type UpdateFileParams struct {
	Size      int64       `json:"size"`
	ModTime   int64       `json:"mod_time"`
	Checksum  string      `json:"checksum"`
	Embedding interface{} `json:"embedding"`
	Metadata  string      `json:"metadata"`
	UpdatedAt int64       `json:"updated_at"`
	ID        string      `json:"id"`
}

// Update file metadata
func (q *Queries) UpdateFile(ctx context.Context, arg UpdateFileParams) (File, error) {
	row := q.queryRow(ctx, q.updateFileStmt, updateFile,
		arg.Size,
		arg.ModTime,
		arg.Checksum,
		arg.Embedding,
		arg.Metadata,
		arg.UpdatedAt,
		arg.ID,
	)
	var i File
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.FilePath,
		&i.Size,
		&i.ModTime,
		&i.IsDir,
		&i.Checksum,
		&i.Embedding,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
